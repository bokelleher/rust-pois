<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>POIS Admin</title>
  <link rel="stylesheet" href="/static/app.css">
  <script type="module">
    import { h, render } from "https://esm.sh/preact@10.24.3";
    import htm from "https://esm.sh/htm@3.1.1";
    import * as hooks from "https://esm.sh/preact@10.24.3/hooks";
    
    const html = htm.bind(h);
    
    function Header() {
      return html`
        <header class="topbar">
          <div class="brand">
            <a href="/">
              <!-- Option 1: Use your own logo image -->
              <!-- <img src="/static/logo.png" alt="POIS" class="logo" /> -->
              
              <!-- Option 2: Use text logo (default) -->
              <span class="logo-text">POIS</span>
            </a>
            <a href="/static/admin.html" class="brand-sub">Admin</a>
          </div>
          <nav class="nav">
            <a href="/static/admin.html" class="active">Channels & Rules</a>
            <a href="/static/tools.html">SCTE-35 Builder</a>
            <a href="/static/events.html">Event Monitor</a>
          </nav>
          <div class="spacer"></div>
          <div class="right">
            <span id="tokenDisplay">token: ${localStorage.getItem("pois_token") ? "set" : "unset"}</span>
          </div>
        </header>
      `;
    }
    
    const API = {
      async get(p) { return req("GET", p) },
      async post(p, b) { return req("POST", p, b) },
      async put(p, b) { return req("PUT", p, b) },
      async del(p) { return req("DELETE", p) }
    };
    
    async function req(method, path, body) {
      const token = localStorage.getItem("pois_token") || "";
      const res = await fetch(`/api${path}`, {
        method,
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`
        },
        body: body ? JSON.stringify(body) : undefined
      });
      if (!res.ok) throw new Error(await res.text());
      return res.status === 204 ? null : res.json();
    }
    
    function Toolbar({ onToken }) {
      const [t, setT] = hooks.useState(localStorage.getItem("pois_token") || "");
      return html`
        <div class="toolbar">
          <h1 class="text-xl font-semibold grad-text">POIS Admin</h1>
          <div class="flex gap-2 items-center">
            <input class="w-64" placeholder="Bearer token" value=${t} onInput=${e => setT(e.target.value)} />
            <button class="btn btn-primary" onClick=${() => { localStorage.setItem("pois_token", t); onToken(t) }}>Save</button>
          </div>
        </div>
      `;
    }
    
    function Channels({ onSelect, selected }) {
      const [data, setData] = hooks.useState(null);
      const [err, setErr] = hooks.useState(null);
      
      hooks.useEffect(() => {
        (async () => {
          try {
            setData(await API.get("/channels"));
          } catch (e) {
            setErr(String(e));
          }
        })();
      }, []);
      
      if (err) return html`<div class="p-4 text-error">${err}</div>`;
      if (!data) return html`<div class="p-4 text-muted">Loading…</div>`;
      
      const add = async () => {
        const name = prompt("Channel name?") || "";
        if (!name) return;
        await API.post("/channels", { name });
        location.reload();
      };
      
      const toggle = async (ch) => {
        await API.put(`/channels/${ch.id}`, {
          name: ch.name,
          enabled: !ch.enabled,
          timezone: ch.timezone
        });
        location.reload();
      };
      
      const deleteChannel = async (ch) => {
        if (!confirm(`Delete channel "${ch.name}"? This will also delete all associated rules.`)) return;
        try {
          await API.del(`/channels/${ch.id}`);
          location.reload();
        } catch (e) {
          alert(`Failed to delete channel: ${e.message}`);
        }
      };
      
      return html`
        <div class="p-4">
          <div class="flex items-center justify-between mb-4">
            <div class="font-semibold text-sm text-muted" style="text-transform: uppercase; letter-spacing: 0.5px;">Channels</div>
            <button class="btn btn-primary btn-small" onClick=${add}>+ Add</button>
          </div>
          <div class="channel-list">
            ${data.map(ch => html`
              <div class="channel-item ${selected?.id === ch.id ? 'active' : ''}" onClick=${() => onSelect(ch)}>
                <div class="flex-col">
                  <div class="font-medium">${ch.name}</div>
                  <div class="text-xs text-muted">${ch.enabled ? 'Enabled' : 'Disabled'}</div>
                </div>
                <div class="flex gap-2">
                  <button class="btn btn-small" onClick=${(e) => { e.stopPropagation(); toggle(ch); }}>
                    ${ch.enabled ? 'Disable' : 'Enable'}
                  </button>
                  <button class="btn btn-small text-error" onClick=${(e) => { e.stopPropagation(); deleteChannel(ch); }}>
                    Delete
                  </button>
                </div>
              </div>
            `)}
          </div>
        </div>
      `;
    }
    
    function Rules({ channel }) {
      const [rules, setRules] = hooks.useState(null);
      const [err, setErr] = hooks.useState(null);
      const [editingId, setEditingId] = hooks.useState(null);
      const [draft, setDraft] = hooks.useState(null);
      const [saving, setSaving] = hooks.useState(false);

      const fetchRules = hooks.useCallback(async () => {
        try {
          setErr(null);
          console.log('Fetching rules for channel:', channel.id);
          const data = await API.get(`/channels/${channel.id}/rules`);
          console.log('Rules data received:', data);
          
          // Clean up any rules with "null" strings
          const cleanedData = data.map(rule => ({
            ...rule,
            match_json: rule.match_json === "null" ? "{}" : rule.match_json,
            params_json: rule.params_json === "null" ? "{}" : rule.params_json
          }));
          
          setRules(cleanedData);
        } catch (e) {
          console.error('Error fetching rules:', e);
          setErr(String(e));
        }
      }, [channel.id]);

      hooks.useEffect(() => {
        setRules(null);
        setEditingId(null);
        setDraft(null);
        fetchRules();
      }, [fetchRules]);

      if (err) return html`<div class="p-4 text-error">${err}</div>`;
      if (!rules) return html`<div class="p-4 text-muted">Loading rules…</div>`;

      const addRule = async () => {
        const name = prompt("Rule name?") || "";
        if (!name) return;
        try {
          await API.post(`/channels/${channel.id}/rules`, {
            name,
            priority: 100,
            enabled: true,
            match_json: {},  // Send as object, not null
            action: "noop",
            params_json: {}  // Send as object, not null
          });
          await fetchRules();
        } catch (e) {
          alert(`Failed to add rule: ${e.message}`);
        }
      };

      const deleteRule = async (ruleId) => {
        if (!confirm("Delete this rule?")) return;
        try {
          await API.del(`/rules/${ruleId}`);
          await fetchRules();
        } catch (e) {
          alert(`Failed to delete rule: ${e.message}`);
        }
      };

      const toggleRule = async (rule) => {
        try {
          await API.put(`/rules/${rule.id}`, {
            name: rule.name,
            priority: rule.priority,
            enabled: rule.enabled === 0,  // Toggle: 0 -> true, 1 -> false
            match_json: JSON.parse(rule.match_json),
            action: rule.action,
            params_json: JSON.parse(rule.params_json)
          });
          await fetchRules();
        } catch (e) {
          alert(`Failed to update rule: ${e.message}`);
        }
      };

      const startEdit = (rule) => {
        setEditingId(rule.id);
        setSaving(false);
        // Format JSON strings nicely for editing
        let formattedMatch = rule.match_json === "null" ? "{}" : rule.match_json;
        let formattedParams = rule.params_json === "null" ? "{}" : rule.params_json;
        
        try {
          formattedMatch = JSON.stringify(JSON.parse(formattedMatch), null, 2);
        } catch (e) {
          formattedMatch = "{}";
        }
        try {
          formattedParams = JSON.stringify(JSON.parse(formattedParams), null, 2);
        } catch (e) {
          formattedParams = "{}";
        }
        
        setDraft({
          name: rule.name,
          priority: String(rule.priority),
          match_json: formattedMatch,
          action: rule.action,
          params_json: formattedParams
        });
      };

      const cancelEdit = () => {
        setEditingId(null);
        setDraft(null);
        setSaving(false);
      };

      const saveEdit = async (rule) => {
        if (!draft) return;
        
        const trimmedName = (draft.name || "").trim();
        if (!trimmedName) {
          alert("Rule name is required.");
          return;
        }
        
        const priority = Number.parseInt(draft.priority, 10);
        if (!Number.isFinite(priority)) {
          alert("Priority must be a number.");
          return;
        }

        // Parse JSON fields
        let matchJson, paramsJson;
        try {
          matchJson = JSON.parse(draft.match_json);
        } catch (e) {
          alert(`Invalid Match JSON: ${e.message}`);
          return;
        }

        try {
          paramsJson = JSON.parse(draft.params_json);
        } catch (e) {
          alert(`Invalid Params JSON: ${e.message}`);
          return;
        }
        
        setSaving(true);
        try {
          await API.put(`/rules/${rule.id}`, {
            name: trimmedName,
            priority,
            enabled: rule.enabled !== 0,  // Convert 1/0 to true/false
            match_json: matchJson,
            action: draft.action,
            params_json: paramsJson
          });
          cancelEdit();
          await fetchRules();
        } catch (e) {
          alert(`Failed to save: ${e.message}`);
          setSaving(false);
        }
      };

      return html`
        <div class="p-4">
          <div class="flex items-center justify-between mb-4">
            <h2 class="font-semibold">Rules for ${channel.name}</h2>
            <button class="btn btn-primary" onClick=${addRule}>+ Add Rule</button>
          </div>
          
          ${rules.length === 0 ? html`
            <div class="empty-state">
              <div class="empty-state-title">No rules configured</div>
              <div class="empty-state-text">Add a rule to get started.</div>
            </div>
          ` : html`
            <div style="display: flex; flex-direction: column; gap: 12px;">
              ${rules.map(rule => {
                const isEditing = editingId === rule.id;
                const displayMatch = rule.match_json || '{}';
                const displayParams = rule.params_json || '{}';
                
                return html`
                  <div key=${rule.id} class="rule-card">
                    <div class="flex items-center justify-between mb-3">
                      ${isEditing ? html`
                        <input 
                          class="w-64" 
                          value=${draft?.name || ""} 
                          onInput=${e => setDraft(prev => ({ ...prev, name: e.target.value }))} 
                          placeholder="Rule name"
                        />
                      ` : html`
                        <div class="font-medium">${rule.name || 'Untitled'}</div>
                      `}
                      <div class="flex gap-2">
                        ${isEditing ? html`
                          <button 
                            class="btn btn-small btn-primary" 
                            disabled=${saving} 
                            onClick=${() => saveEdit(rule)}
                          >
                            ${saving ? 'Saving…' : 'Save'}
                          </button>
                          <button 
                            class="btn btn-small" 
                            disabled=${saving} 
                            onClick=${cancelEdit}
                          >
                            Cancel
                          </button>
                        ` : html`
                          <button 
                            class="btn btn-small" 
                            onClick=${() => toggleRule(rule)}
                          >
                            ${rule.enabled ? 'Disable' : 'Enable'}
                          </button>
                          <button 
                            class="btn btn-small" 
                            onClick=${() => startEdit(rule)}
                          >
                            Edit
                          </button>
                          <button 
                            class="btn btn-small text-error" 
                            onClick=${() => deleteRule(rule.id)}
                          >
                            Delete
                          </button>
                        `}
                      </div>
                    </div>
                    ${isEditing ? html`
                      <div style="display: flex; flex-direction: column; gap: 12px; font-size: 13px;">
                        <label class="flex flex-col gap-1">
                          <span class="text-xs text-muted" style="letter-spacing: 0.3px; text-transform: uppercase;">Priority</span>
                          <input 
                            type="number" 
                            min="0" 
                            class="w-32" 
                            value=${draft?.priority || "0"} 
                            onInput=${e => setDraft(prev => ({ ...prev, priority: e.target.value }))} 
                          />
                        </label>
                        <label class="flex flex-col gap-1">
                          <span class="text-xs text-muted" style="letter-spacing: 0.3px; text-transform: uppercase;">Match JSON</span>
                          <textarea 
                            rows="4" 
                            class="font-mono text-xs" 
                            value=${draft?.match_json || "{}"} 
                            onInput=${e => setDraft(prev => ({ ...prev, match_json: e.target.value }))}
                            placeholder='{"anyOf": [{"scte35.command": "time_signal"}]}'
                          ></textarea>
                        </label>
                        <label class="flex flex-col gap-1">
                          <span class="text-xs text-muted" style="letter-spacing: 0.3px; text-transform: uppercase;">Action</span>
                          <select 
                            class="w-48" 
                            value=${draft?.action || "noop"} 
                            onChange=${e => setDraft(prev => ({ ...prev, action: e.target.value }))}
                          >
                            <option value="noop">noop</option>
                            <option value="delete">delete</option>
                            <option value="replace">replace</option>
                          </select>
                        </label>
                        <label class="flex flex-col gap-1">
                          <span class="text-xs text-muted" style="letter-spacing: 0.3px; text-transform: uppercase;">Params JSON</span>
                          <textarea 
                            rows="4" 
                            class="font-mono text-xs" 
                            value=${draft?.params_json || "{}"} 
                            onInput=${e => setDraft(prev => ({ ...prev, params_json: e.target.value }))}
                            placeholder='{"scte35_b64": "..."}'
                          ></textarea>
                        </label>
                      </div>
                    ` : html`
                      <div style="display: flex; flex-direction: column; gap: 8px; font-size: 13px;">
                        <div><strong>Priority:</strong> ${rule.priority || 0}</div>
                        <div>
                          <strong>Match:</strong> 
                          <pre class="text-xs mt-1" style="max-height: 150px; overflow: auto;">${displayMatch}</pre>
                        </div>
                        <div><strong>Action:</strong> <span class=${'action-' + (rule.action || 'noop')}>${rule.action || 'noop'}</span></div>
                        <div>
                          <strong>Params:</strong> 
                          <pre class="text-xs mt-1" style="max-height: 150px; overflow: auto;">${displayParams}</pre>
                        </div>
                        <div class="text-muted">${rule.enabled ? 'Active' : 'Inactive'}</div>
                      </div>
                    `}
                  </div>
                `;
              })}
            </div>
          `}

          <${DryRun} channel=${channel} />
        </div>
      `;
    }
    
    function DryRun({ channel }) {
      const [xml, setXml] = hooks.useState(`<SignalProcessingEvent xmlns="urn:cablelabs:iptvservices:esam:xsd:signal:1" xmlns:sig="urn:cablelabs:md:xsd:signaling:3.0"><AcquiredSignal acquisitionSignalID="abc-123"><sig:UTCPoint utcPoint="2012-09-18T10:14:34Z"/></AcquiredSignal></SignalProcessingEvent>`);
      const [result, setResult] = hooks.useState(null);
      
      const run = async () => {
        try {
          setResult(await API.post("/dryrun", { channel: channel.name, esam_xml: xml }));
        } catch (e) {
          alert(e);
        }
      };
      
      return html`
        <div class="mt-6 panel">
          <div class="card-title mb-4">Dry-run ESAM against rules</div>
          <textarea class="w-full font-mono text-xs" rows="8" value=${xml} onInput=${e => setXml(e.target.value)}></textarea>
          <div class="mt-2 flex items-center gap-2">
            <button class="btn btn-primary" onClick=${run}>Run Test</button>
            ${result && html`
              <div class="text-sm">
                → Action: <strong class="action-${result.action}">${result.action}</strong> 
                ${result.matched_rule_id ? `(rule ${result.matched_rule_id})` : ''} 
                — ${result.note}
              </div>
            `}
          </div>
        </div>
      `;
    }
    
    function App() {
      const [sel, setSel] = hooks.useState(null);
      
      return html`
        <div class="min-h-screen">
          <${Header} />
          <${Toolbar} onToken=${() => {}} />
          <div class="grid grid-cols-12">
            <div class="col-span-3 border-r admin-sidebar">
              <${Channels} onSelect=${setSel} selected=${sel} />
            </div>
            <div class="col-span-9">
              ${sel ? html`<${Rules} channel=${sel} />` : html`
                <div class="empty-state" style="padding: 80px 20px;">
                  <div class="empty-state-title">Select a channel</div>
                  <div class="empty-state-text">Choose or add a channel to manage its rules.</div>
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }
    
    render(html`<${App} />`, document.body);
  </script>
  <script src="/static/app.js"></script>
</head>
<body></body>
</html>
